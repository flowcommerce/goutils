package registry

/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.73
 * apidoc:0.11.27 http://www.apidoc.me/flow/registry/0.0.73/go_1_5_client
 */

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/flowcommerce/goutils/common"
	"html"
	"io"
	"net/http"
	"net/url"
	"strconv"
)

const BaseUrl = "https://registry.api.flow.io"
const UserAgent = "apidoc:0.11.27 http://www.apidoc.me/flow/registry/0.0.73/go_1_5_client"
const Version = "0.0.73"
const VersionMajor = 0

type Client struct {
	HttpClient *http.Client
	Username   string
	Password   string
	BaseUrl    string
}

type ClientRequestBody struct {
	contentType string
	bytes       io.Reader
}

type Application struct {
	Id           string   `json:"id"`
	Ports        []Port   `json:"ports"`
	Dependencies []string `json:"dependencies"`
}

func ApplicationFromMap(data interface{}) Application {
	b, err := json.Marshal(data)
	if err == nil {
		return ApplicationFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ApplicationFromJson(bytes io.Reader) Application {
	var application Application
	json.NewDecoder(bytes).Decode(&application)
	return application
}

type ApplicationForm struct {
	Id         string   `json:"id"`
	Service    string   `json:"service"`
	External   int64    `json:"external,omitempty"`
	Internal   int64    `json:"internal,omitempty"`
	Dependency []string `json:"dependency,omitempty"`
}

func ApplicationFormFromMap(data interface{}) ApplicationForm {
	b, err := json.Marshal(data)
	if err == nil {
		return ApplicationFormFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ApplicationFormFromJson(bytes io.Reader) ApplicationForm {
	var applicationForm ApplicationForm
	json.NewDecoder(bytes).Decode(&applicationForm)
	return applicationForm
}

type ApplicationPutForm struct {
	Service    string   `json:"service,omitempty"`
	External   int64    `json:"external,omitempty"`
	Internal   int64    `json:"internal,omitempty"`
	Dependency []string `json:"dependency,omitempty"`
}

func ApplicationPutFormFromMap(data interface{}) ApplicationPutForm {
	b, err := json.Marshal(data)
	if err == nil {
		return ApplicationPutFormFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ApplicationPutFormFromJson(bytes io.Reader) ApplicationPutForm {
	var applicationPutForm ApplicationPutForm
	json.NewDecoder(bytes).Decode(&applicationPutForm)
	return applicationPutForm
}

type ApplicationVersion struct {
	Id          string            `json:"id"`
	Timestamp   string            `json:"timestamp"`
	Type        common.ChangeType `json:"type"`
	Application Application       `json:"application"`
}

func ApplicationVersionFromMap(data interface{}) ApplicationVersion {
	b, err := json.Marshal(data)
	if err == nil {
		return ApplicationVersionFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ApplicationVersionFromJson(bytes io.Reader) ApplicationVersion {
	var applicationVersion ApplicationVersion
	json.NewDecoder(bytes).Decode(&applicationVersion)
	return applicationVersion
}

type Port struct {
	Service  ServiceReference `json:"service"`
	External int64            `json:"external"`
	Internal int64            `json:"internal"`
}

func PortFromMap(data interface{}) Port {
	b, err := json.Marshal(data)
	if err == nil {
		return PortFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func PortFromJson(bytes io.Reader) Port {
	var port Port
	json.NewDecoder(bytes).Decode(&port)
	return port
}

/**
 * A service is used to identify what type of software is actually running. We use
 * this to enable setting up application types with enough configuration info by
 * default to support our use cases around docker, CI, etc. The name service comes
 * from
 * https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
 */
type Service struct {
	Id          string `json:"id"`
	DefaultPort int64  `json:"default_port"`
}

func ServiceFromMap(data interface{}) Service {
	b, err := json.Marshal(data)
	if err == nil {
		return ServiceFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ServiceFromJson(bytes io.Reader) Service {
	var service Service
	json.NewDecoder(bytes).Decode(&service)
	return service
}

type ServiceForm struct {
	Id          string `json:"id"`
	DefaultPort int64  `json:"default_port"`
}

func ServiceFormFromMap(data interface{}) ServiceForm {
	b, err := json.Marshal(data)
	if err == nil {
		return ServiceFormFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ServiceFormFromJson(bytes io.Reader) ServiceForm {
	var serviceForm ServiceForm
	json.NewDecoder(bytes).Decode(&serviceForm)
	return serviceForm
}

type ServicePutForm struct {
	DefaultPort int64 `json:"default_port"`
}

func ServicePutFormFromMap(data interface{}) ServicePutForm {
	b, err := json.Marshal(data)
	if err == nil {
		return ServicePutFormFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ServicePutFormFromJson(bytes io.Reader) ServicePutForm {
	var servicePutForm ServicePutForm
	json.NewDecoder(bytes).Decode(&servicePutForm)
	return servicePutForm
}

type ServiceReference struct {
	Id string `json:"id"`
}

func ServiceReferenceFromMap(data interface{}) ServiceReference {
	b, err := json.Marshal(data)
	if err == nil {
		return ServiceReferenceFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ServiceReferenceFromJson(bytes io.Reader) ServiceReference {
	var serviceReference ServiceReference
	json.NewDecoder(bytes).Decode(&serviceReference)
	return serviceReference
}

type ServiceVersion struct {
	Id        string            `json:"id"`
	Timestamp string            `json:"timestamp"`
	Type      common.ChangeType `json:"type"`
	Service   Service           `json:"service"`
}

func ServiceVersionFromMap(data interface{}) ServiceVersion {
	b, err := json.Marshal(data)
	if err == nil {
		return ServiceVersionFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func ServiceVersionFromJson(bytes io.Reader) ServiceVersion {
	var serviceVersion ServiceVersion
	json.NewDecoder(bytes).Decode(&serviceVersion)
	return serviceVersion
}

type ApplicationsGetParams struct {
	Id      []string
	Port    []int64
	Service []string
	Prefix  string
	Q       string
	Limit   int64
	Offset  int64
	Sort    string
}

type ApplicationsGetResponse struct {
	StatusCode   int
	Response     *http.Response
	Error        error
	Applications []Application
}

func ApplicationsGet(client Client, params ApplicationsGetParams) ApplicationsGetResponse {

	requestUrl := fmt.Sprintf("%s/applications", client.BaseUrl)
	urlValues := url.Values{}
	for _, value := range params.Id {
		urlValues.Add("id", value)
	}
	for _, value := range params.Port {
		urlValues.Add("port", strconv.FormatInt(value, 10))
	}
	for _, value := range params.Service {
		urlValues.Add("service", value)
	}
	if "" != params.Prefix {
		urlValues.Add("prefix", params.Prefix)
	}
	if "" != params.Q {
		urlValues.Add("q", params.Q)
	}
	if 0 == params.Limit {
		urlValues.Add("limit", strconv.FormatInt(25, 10))
	} else {
		urlValues.Add("limit", strconv.FormatInt(params.Limit, 10))
	}
	if 0 == params.Offset {
		urlValues.Add("offset", strconv.FormatInt(0, 10))
	} else {
		urlValues.Add("offset", strconv.FormatInt(params.Offset, 10))
	}
	if "" == params.Sort {
		urlValues.Add("sort", "-created_at")
	} else {
		urlValues.Add("sort", params.Sort)
	}

	encodedValues := urlValues.Encode()
	if encodedValues != "" {
		requestUrl += "?" + encodedValues
	}

	request, err := buildRequest(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return ApplicationsGetResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ApplicationsGetResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ApplicationsGetResponse{StatusCode: resp.StatusCode, Response: resp, Applications: func() []Application {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []Application
			for _, el := range tmp {
				all = append(all, ApplicationFromMap(el))
			}
			return all
		}()}

	case 401:
		return ApplicationsGetResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return ApplicationsGetResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ApplicationsGetVersionsParams struct {
	Id          []string
	Application []string
	Limit       int64
	Offset      int64
	Sort        string
}

type ApplicationsGetVersionsResponse struct {
	StatusCode          int
	Response            *http.Response
	Error               error
	ApplicationVersions []ApplicationVersion
}

func ApplicationsGetVersions(client Client, params ApplicationsGetVersionsParams) ApplicationsGetVersionsResponse {

	requestUrl := fmt.Sprintf("%s/applications/versions", client.BaseUrl)
	urlValues := url.Values{}
	for _, value := range params.Id {
		urlValues.Add("id", value)
	}
	for _, value := range params.Application {
		urlValues.Add("application", value)
	}
	if 0 == params.Limit {
		urlValues.Add("limit", strconv.FormatInt(25, 10))
	} else {
		urlValues.Add("limit", strconv.FormatInt(params.Limit, 10))
	}
	if 0 == params.Offset {
		urlValues.Add("offset", strconv.FormatInt(0, 10))
	} else {
		urlValues.Add("offset", strconv.FormatInt(params.Offset, 10))
	}
	if "" == params.Sort {
		urlValues.Add("sort", "journal_timestamp")
	} else {
		urlValues.Add("sort", params.Sort)
	}

	encodedValues := urlValues.Encode()
	if encodedValues != "" {
		requestUrl += "?" + encodedValues
	}

	request, err := buildRequest(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return ApplicationsGetVersionsResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ApplicationsGetVersionsResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ApplicationsGetVersionsResponse{StatusCode: resp.StatusCode, Response: resp, ApplicationVersions: func() []ApplicationVersion {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []ApplicationVersion
			for _, el := range tmp {
				all = append(all, ApplicationVersionFromMap(el))
			}
			return all
		}()}

	case 401:
		return ApplicationsGetVersionsResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return ApplicationsGetVersionsResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ApplicationsGetByIdResponse struct {
	StatusCode  int
	Response    *http.Response
	Error       error
	Application Application
}

func ApplicationsGetById(client Client, id string) ApplicationsGetByIdResponse {

	requestUrl := fmt.Sprintf("%s/applications/%s", client.BaseUrl, html.EscapeString(id))

	request, err := buildRequest(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return ApplicationsGetByIdResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ApplicationsGetByIdResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ApplicationsGetByIdResponse{StatusCode: resp.StatusCode, Response: resp, Application: ApplicationFromJson(resp.Body)}

	case 401:
		return ApplicationsGetByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 404:
		return ApplicationsGetByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return ApplicationsGetByIdResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ApplicationsPostResponse struct {
	StatusCode   int
	Response     *http.Response
	Error        error
	Application  Application
	CommonErrors []common.Error
}

func ApplicationsPost(client Client, applicationForm ApplicationForm) ApplicationsPostResponse {

	requestUrl := fmt.Sprintf("%s/applications", client.BaseUrl)

	bodyDocument, err := json.Marshal(applicationForm)
	if err != nil {
		return ApplicationsPostResponse{Error: err}
	}
	body := ClientRequestBody{contentType: "application/json", bytes: bytes.NewReader(bodyDocument)}

	request, err := buildRequest(client, "POST", requestUrl, body)
	if err != nil {
		return ApplicationsPostResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ApplicationsPostResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 201:
		return ApplicationsPostResponse{StatusCode: resp.StatusCode, Response: resp, Application: ApplicationFromJson(resp.Body)}

	case 401:
		return ApplicationsPostResponse{StatusCode: resp.StatusCode, Response: resp}

	case 422:
		return ApplicationsPostResponse{StatusCode: resp.StatusCode, Response: resp, CommonErrors: func() []common.Error {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []common.Error
			for _, el := range tmp {
				all = append(all, common.ErrorFromMap(el))
			}
			return all
		}()}

	default:
		return ApplicationsPostResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ApplicationsPutByIdResponse struct {
	StatusCode   int
	Response     *http.Response
	Error        error
	Application  Application
	CommonErrors []common.Error
}

func ApplicationsPutById(client Client, id string, applicationPutForm ApplicationPutForm) ApplicationsPutByIdResponse {

	requestUrl := fmt.Sprintf("%s/applications/%s", client.BaseUrl, html.EscapeString(id))

	bodyDocument, err := json.Marshal(applicationPutForm)
	if err != nil {
		return ApplicationsPutByIdResponse{Error: err}
	}
	body := ClientRequestBody{contentType: "application/json", bytes: bytes.NewReader(bodyDocument)}

	request, err := buildRequest(client, "PUT", requestUrl, body)
	if err != nil {
		return ApplicationsPutByIdResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ApplicationsPutByIdResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ApplicationsPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, Application: ApplicationFromJson(resp.Body)}

	case 201:
		return ApplicationsPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, Application: ApplicationFromJson(resp.Body)}

	case 401:
		return ApplicationsPutByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 422:
		return ApplicationsPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, CommonErrors: func() []common.Error {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []common.Error
			for _, el := range tmp {
				all = append(all, common.ErrorFromMap(el))
			}
			return all
		}()}

	default:
		return ApplicationsPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ApplicationsDeleteByIdResponse struct {
	StatusCode int
	Response   *http.Response
	Error      error
}

func ApplicationsDeleteById(client Client, id string) ApplicationsDeleteByIdResponse {

	requestUrl := fmt.Sprintf("%s/applications/%s", client.BaseUrl, html.EscapeString(id))

	request, err := buildRequest(client, "DELETE", requestUrl, ClientRequestBody{})
	if err != nil {
		return ApplicationsDeleteByIdResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ApplicationsDeleteByIdResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 204:
		return ApplicationsDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 401:
		return ApplicationsDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 404:
		return ApplicationsDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return ApplicationsDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ServicesGetParams struct {
	Id     []string
	Limit  int64
	Offset int64
	Sort   string
}

type ServicesGetResponse struct {
	StatusCode int
	Response   *http.Response
	Error      error
	Services   []Service
}

func ServicesGet(client Client, params ServicesGetParams) ServicesGetResponse {

	requestUrl := fmt.Sprintf("%s/services", client.BaseUrl)
	urlValues := url.Values{}
	for _, value := range params.Id {
		urlValues.Add("id", value)
	}
	if 0 == params.Limit {
		urlValues.Add("limit", strconv.FormatInt(25, 10))
	} else {
		urlValues.Add("limit", strconv.FormatInt(params.Limit, 10))
	}
	if 0 == params.Offset {
		urlValues.Add("offset", strconv.FormatInt(0, 10))
	} else {
		urlValues.Add("offset", strconv.FormatInt(params.Offset, 10))
	}
	if "" == params.Sort {
		urlValues.Add("sort", "-created_at")
	} else {
		urlValues.Add("sort", params.Sort)
	}

	encodedValues := urlValues.Encode()
	if encodedValues != "" {
		requestUrl += "?" + encodedValues
	}

	request, err := buildRequest(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return ServicesGetResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ServicesGetResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ServicesGetResponse{StatusCode: resp.StatusCode, Response: resp, Services: func() []Service {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []Service
			for _, el := range tmp {
				all = append(all, ServiceFromMap(el))
			}
			return all
		}()}

	case 401:
		return ServicesGetResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return ServicesGetResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ServicesGetVersionsParams struct {
	Id      []string
	Service []string
	Limit   int64
	Offset  int64
	Sort    string
}

type ServicesGetVersionsResponse struct {
	StatusCode      int
	Response        *http.Response
	Error           error
	ServiceVersions []ServiceVersion
}

func ServicesGetVersions(client Client, params ServicesGetVersionsParams) ServicesGetVersionsResponse {

	requestUrl := fmt.Sprintf("%s/services/versions", client.BaseUrl)
	urlValues := url.Values{}
	for _, value := range params.Id {
		urlValues.Add("id", value)
	}
	for _, value := range params.Service {
		urlValues.Add("service", value)
	}
	if 0 == params.Limit {
		urlValues.Add("limit", strconv.FormatInt(25, 10))
	} else {
		urlValues.Add("limit", strconv.FormatInt(params.Limit, 10))
	}
	if 0 == params.Offset {
		urlValues.Add("offset", strconv.FormatInt(0, 10))
	} else {
		urlValues.Add("offset", strconv.FormatInt(params.Offset, 10))
	}
	if "" == params.Sort {
		urlValues.Add("sort", "journal_timestamp")
	} else {
		urlValues.Add("sort", params.Sort)
	}

	encodedValues := urlValues.Encode()
	if encodedValues != "" {
		requestUrl += "?" + encodedValues
	}

	request, err := buildRequest(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return ServicesGetVersionsResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ServicesGetVersionsResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ServicesGetVersionsResponse{StatusCode: resp.StatusCode, Response: resp, ServiceVersions: func() []ServiceVersion {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []ServiceVersion
			for _, el := range tmp {
				all = append(all, ServiceVersionFromMap(el))
			}
			return all
		}()}

	case 401:
		return ServicesGetVersionsResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return ServicesGetVersionsResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ServicesGetByIdResponse struct {
	StatusCode int
	Response   *http.Response
	Error      error
	Service    Service
}

func ServicesGetById(client Client, id string) ServicesGetByIdResponse {

	requestUrl := fmt.Sprintf("%s/services/%s", client.BaseUrl, html.EscapeString(id))

	request, err := buildRequest(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return ServicesGetByIdResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ServicesGetByIdResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ServicesGetByIdResponse{StatusCode: resp.StatusCode, Response: resp, Service: ServiceFromJson(resp.Body)}

	case 401:
		return ServicesGetByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 404:
		return ServicesGetByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return ServicesGetByIdResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ServicesPostResponse struct {
	StatusCode   int
	Response     *http.Response
	Error        error
	CommonErrors []common.Error
	Service      Service
}

func ServicesPost(client Client, serviceForm ServiceForm) ServicesPostResponse {

	requestUrl := fmt.Sprintf("%s/services", client.BaseUrl)

	bodyDocument, err := json.Marshal(serviceForm)
	if err != nil {
		return ServicesPostResponse{Error: err}
	}
	body := ClientRequestBody{contentType: "application/json", bytes: bytes.NewReader(bodyDocument)}

	request, err := buildRequest(client, "POST", requestUrl, body)
	if err != nil {
		return ServicesPostResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ServicesPostResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 201:
		return ServicesPostResponse{StatusCode: resp.StatusCode, Response: resp, Service: ServiceFromJson(resp.Body)}

	case 401:
		return ServicesPostResponse{StatusCode: resp.StatusCode, Response: resp}

	case 422:
		return ServicesPostResponse{StatusCode: resp.StatusCode, Response: resp, CommonErrors: func() []common.Error {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []common.Error
			for _, el := range tmp {
				all = append(all, common.ErrorFromMap(el))
			}
			return all
		}()}

	default:
		return ServicesPostResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ServicesPutByIdResponse struct {
	StatusCode   int
	Response     *http.Response
	Error        error
	CommonErrors []common.Error
	Service      Service
}

func ServicesPutById(client Client, id string, servicePutForm ServicePutForm) ServicesPutByIdResponse {

	requestUrl := fmt.Sprintf("%s/services/%s", client.BaseUrl, html.EscapeString(id))

	bodyDocument, err := json.Marshal(servicePutForm)
	if err != nil {
		return ServicesPutByIdResponse{Error: err}
	}
	body := ClientRequestBody{contentType: "application/json", bytes: bytes.NewReader(bodyDocument)}

	request, err := buildRequest(client, "PUT", requestUrl, body)
	if err != nil {
		return ServicesPutByIdResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ServicesPutByIdResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return ServicesPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, Service: ServiceFromJson(resp.Body)}

	case 201:
		return ServicesPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, Service: ServiceFromJson(resp.Body)}

	case 401:
		return ServicesPutByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 422:
		return ServicesPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, CommonErrors: func() []common.Error {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []common.Error
			for _, el := range tmp {
				all = append(all, common.ErrorFromMap(el))
			}
			return all
		}()}

	default:
		return ServicesPutByIdResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type ServicesDeleteByIdResponse struct {
	StatusCode   int
	Response     *http.Response
	Error        error
	CommonErrors []common.Error
}

func ServicesDeleteById(client Client, id string) ServicesDeleteByIdResponse {

	requestUrl := fmt.Sprintf("%s/services/%s", client.BaseUrl, html.EscapeString(id))

	request, err := buildRequest(client, "DELETE", requestUrl, ClientRequestBody{})
	if err != nil {
		return ServicesDeleteByIdResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return ServicesDeleteByIdResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 204:
		return ServicesDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 401:
		return ServicesDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 404:
		return ServicesDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp}

	case 422:
		return ServicesDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp, CommonErrors: func() []common.Error {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []common.Error
			for _, el := range tmp {
				all = append(all, common.ErrorFromMap(el))
			}
			return all
		}()}

	default:
		return ServicesDeleteByIdResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

func buildRequest(client Client, method, urlStr string, body ClientRequestBody) (*http.Request, error) {

	request, err := http.NewRequest(method, urlStr, body.bytes)
	if err != nil {
		return nil, err
	}

	request.Header = map[string][]string{
		"User-Agent":             {UserAgent},
		"X-Apidoc-Version":       {Version},
		"X-Apidoc-Version-Major": {strconv.Itoa(VersionMajor)},
	}

	if body.contentType != "" {
		request.Header["Content-type"] = []string{body.contentType}
	}

	if client.Username != "" {
		request.SetBasicAuth(client.Username, client.Password)
	}

	return request, nil

}
