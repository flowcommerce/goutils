package dockerregistry

/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.4
 * apidoc:0.11.27 http://www.apidoc.me/flow/docker-registry/0.0.4/go_1_5_client
 */

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/ddliu/go-httpclient"
	"html"
	"io"
	"net/http"
	"strconv"
)

const BaseUrl = "https://registry.hub.docker.com"
const UserAgent = "apidoc:0.11.27 http://www.apidoc.me/flow/docker-registry/0.0.4/go_1_5_client"
const Version = "0.0.4"
const VersionMajor = 0

type Client struct {
	HttpClient *http.Client
	Username   string
	Password   string
	BaseUrl    string
	JwtToken   string
}

type ClientRequestBody struct {
	contentType string
	bytes       io.Reader
}

type Build struct {
	RepoWebUrl string `json:"repo_web_url"`
}

func BuildFromMap(data interface{}) Build {
	b, err := json.Marshal(data)
	if err == nil {
		return BuildFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func BuildFromJson(bytes io.Reader) Build {
	var build Build
	json.NewDecoder(bytes).Decode(&build)
	return build
}

type BuildForm struct {
	Active            string     `json:"active"`
	BuildTags         []BuildTag `json:"build_tags"`
	Description       string     `json:"description"`
	DockerhubRepoName string     `json:"dockerhub_repo_name"`
	IsPrivate         string     `json:"is_private"`
	Name              string     `json:"name"`
	Namespace         string     `json:"namespace"`
	Provider          string     `json:"provider"`
	VcsRepoName       string     `json:"vcs_repo_name"`
}

func BuildFormFromMap(data interface{}) BuildForm {
	b, err := json.Marshal(data)
	if err == nil {
		return BuildFormFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func BuildFormFromJson(bytes io.Reader) BuildForm {
	var buildForm BuildForm
	json.NewDecoder(bytes).Decode(&buildForm)
	return buildForm
}

type BuildTag struct {
	DockerfileLocation string `json:"dockerfile_location"`
	Name               string `json:"name"`
	SourceName         string `json:"source_name"`
	SourceType         string `json:"source_type"`
	Id                 int64  `json:"id,omitempty"`
}

func BuildTagFromMap(data interface{}) BuildTag {
	b, err := json.Marshal(data)
	if err == nil {
		return BuildTagFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func BuildTagFromJson(bytes io.Reader) BuildTag {
	var buildTag BuildTag
	json.NewDecoder(bytes).Decode(&buildTag)
	return buildTag
}

type Deploykey struct {
	Provider      string `json:"provider,omitempty"`
	ProviderKeyId string `json:"provider_key_id,omitempty"`
	PublicKey     string `json:"public_key,omitempty"`
}

func DeploykeyFromMap(data interface{}) Deploykey {
	b, err := json.Marshal(data)
	if err == nil {
		return DeploykeyFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func DeploykeyFromJson(bytes io.Reader) Deploykey {
	var deploykey Deploykey
	json.NewDecoder(bytes).Decode(&deploykey)
	return deploykey
}

type DockerRepository struct {
	Name string `json:"name"`
}

func DockerRepositoryFromMap(data interface{}) DockerRepository {
	b, err := json.Marshal(data)
	if err == nil {
		return DockerRepositoryFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func DockerRepositoryFromJson(bytes io.Reader) DockerRepository {
	var dockerRepository DockerRepository
	json.NewDecoder(bytes).Decode(&dockerRepository)
	return dockerRepository
}

type Tag struct {
	Layer string `json:"layer"`
	Name  string `json:"name"`
}

func TagFromMap(data interface{}) Tag {
	b, err := json.Marshal(data)
	if err == nil {
		return TagFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func TagFromJson(bytes io.Reader) Tag {
	var tag Tag
	json.NewDecoder(bytes).Decode(&tag)
	return tag
}

type V2Tag struct {
	Results []V2TagDetails `json:"results"`
}

func V2TagFromMap(data interface{}) V2Tag {
	b, err := json.Marshal(data)
	if err == nil {
		return V2TagFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func V2TagFromJson(bytes io.Reader) V2Tag {
	var v2Tag V2Tag
	json.NewDecoder(bytes).Decode(&v2Tag)
	return v2Tag
}

type V2TagDetails struct {
	Name string `json:"name"`
}

func V2TagDetailsFromMap(data interface{}) V2TagDetails {
	b, err := json.Marshal(data)
	if err == nil {
		return V2TagDetailsFromJson(bytes.NewReader(b))
	} else {
		panic(err)
	}
}

func V2TagDetailsFromJson(bytes io.Reader) V2TagDetails {
	var v2TagDetails V2TagDetails
	json.NewDecoder(bytes).Decode(&v2TagDetails)
	return v2TagDetails
}

type DockerRepositoriesPostAutobuildResponse struct {
	StatusCode int
	Response   *http.Response
	Error      error
	Build      Build
}

func DockerRepositoriesPostAutobuild(client Client, org string, repo string, buildForm BuildForm) DockerRepositoriesPostAutobuildResponse {

	requestUrl := fmt.Sprintf("%s/v2/repositories/%s/%s/autobuild/", client.BaseUrl, html.EscapeString(org), html.EscapeString(repo))

	bodyDocument, err := json.Marshal(buildForm)
	if err != nil {
		return DockerRepositoriesPostAutobuildResponse{Error: err}
	}
	body := ClientRequestBody{contentType: "application/json", bytes: bytes.NewReader(bodyDocument)}

	request, err := buildRequest(client, "POST", requestUrl, body)
	if err != nil {
		return DockerRepositoriesPostAutobuildResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return DockerRepositoriesPostAutobuildResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 201:
		return DockerRepositoriesPostAutobuildResponse{StatusCode: resp.StatusCode, Response: resp, Build: BuildFromJson(resp.Body)}

	case 400:
		return DockerRepositoriesPostAutobuildResponse{StatusCode: resp.StatusCode, Response: resp}

	case 401:
		return DockerRepositoriesPostAutobuildResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return DockerRepositoriesPostAutobuildResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type TagsGetResponse struct {
	StatusCode int
	Response   *http.Response
	Error      error
	Tags       []Tag
}

func TagsGet(client Client, org string, repo string) TagsGetResponse {

	requestUrl := fmt.Sprintf("%s/v1/repositories/%s/%s/tags", client.BaseUrl, html.EscapeString(org), html.EscapeString(repo))

	request, err := buildRequest(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return TagsGetResponse{Error: err}
	}

	resp, err := client.HttpClient.Do(request)
	if err != nil {
		return TagsGetResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return TagsGetResponse{StatusCode: resp.StatusCode, Response: resp, Tags: func() []Tag {
			var tmp []interface{}
			json.NewDecoder(resp.Body).Decode(&tmp)
			var all []Tag
			for _, el := range tmp {
				all = append(all, TagFromMap(el))
			}
			return all
		}()}

	case 401:
		return TagsGetResponse{StatusCode: resp.StatusCode, Response: resp}

	default:
		return TagsGetResponse{StatusCode: resp.StatusCode, Response: resp, Error: errors.New(resp.Status)}
	}

}

type V2TagsGetResponse struct {
	StatusCode int
	Response   *http.Response
	Error      error
	V2Tag      V2Tag
}

func V2TagsGet(client Client, org string, repo string) V2TagsGetResponse {

	requestUrl := fmt.Sprintf("%s/v2/repositories/%s/%s/tags/", client.BaseUrl, html.EscapeString(org), html.EscapeString(repo))

	request, err := buildRequestWithAuthToken(client, "GET", requestUrl, ClientRequestBody{})
	if err != nil {
		return V2TagsGetResponse{Error: err}
	}

	resp, err := request.Get(requestUrl, nil)

	if err != nil {
		return V2TagsGetResponse{Error: err}
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case 200:
		return V2TagsGetResponse{StatusCode: resp.StatusCode, Response: resp.Response, V2Tag: V2TagFromJson(resp.Body)}

	case 401:
		return V2TagsGetResponse{StatusCode: resp.StatusCode, Response: resp.Response}

	default:
		return V2TagsGetResponse{StatusCode: resp.StatusCode, Response: resp.Response, Error: errors.New(resp.Status)}
	}

}

func buildRequest(client Client, method, urlStr string, body ClientRequestBody) (*http.Request, error) {

	request, err := http.NewRequest(method, urlStr, body.bytes)
	if err != nil {
		return nil, err
	}

	request.Header = map[string][]string{
		"User-Agent":             {UserAgent},
		"X-Apidoc-Version":       {Version},
		"X-Apidoc-Version-Major": {strconv.Itoa(VersionMajor)},
	}

	if body.contentType != "" {
		request.Header["Content-type"] = []string{body.contentType}
	}

	if client.Username != "" {
		request.SetBasicAuth(client.Username, client.Password)
	}

	return request, nil

}

func buildRequestWithAuthToken(client Client, method, urlStr string, body ClientRequestBody) (*httpclient.HttpClient, error) {
	request := httpclient.
		WithHeader("Authorization", fmt.Sprintf("Bearer %s", client.JwtToken)).
		WithHeader("User-Agent", UserAgent).
		WithHeader("X-Apidoc-Version", Version).
		WithHeader("X-Apidoc-Version-Major", strconv.Itoa(VersionMajor))

	if body.contentType != "" {
		request.WithHeader("Content-type", body.contentType)
	}

	return request, nil

}
